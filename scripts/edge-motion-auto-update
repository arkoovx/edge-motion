#!/usr/bin/env bash
set -euo pipefail

UPDATE_ENV_FILE="${EDGE_MOTION_UPDATE_CONFIG:-/etc/default/edge-motion-update}"
REPO_DIR="${EDGE_MOTION_REPO_DIR:-/opt/edge-motion-src}"
BRANCH="${EDGE_MOTION_UPDATE_BRANCH:-main}"
MANUAL_RUN=0

if [[ -t 1 ]]; then
  MANUAL_RUN=1
fi

status() {
  local text="$1"
  logger -t edge-motion-auto-update "$text"
  if [[ "$MANUAL_RUN" == "1" ]]; then
    echo "$text"
  fi
}

if [[ -f "$UPDATE_ENV_FILE" ]]; then
  # shellcheck disable=SC1090
  source "$UPDATE_ENV_FILE"
fi

: "${EDGE_MOTION_AUTO_UPDATE:=1}"
: "${EDGE_MOTION_REPO_DIR:=$REPO_DIR}"
: "${EDGE_MOTION_UPDATE_BRANCH:=$BRANCH}"
: "${EDGE_MOTION_REPO_SEARCH_PATHS:=}"

if [[ "$EDGE_MOTION_AUTO_UPDATE" != "1" ]]; then
  status "Автообновление отключено в конфиге."
  exit 0
fi

if ! command -v git >/dev/null 2>&1 || ! command -v make >/dev/null 2>&1; then
  status "Зависимости git/make не найдены, обновление пропущено."
  exit 0
fi

is_repo_dir() {
  local dir="$1"
  [[ -n "$dir" && -d "$dir/.git" && -f "$dir/Makefile" && -f "$dir/edge-motion.c" ]]
}

find_repo_dir() {
  local candidate

  if is_repo_dir "$EDGE_MOTION_REPO_DIR"; then
    printf '%s' "$EDGE_MOTION_REPO_DIR"
    return 0
  fi

  local -a search_dirs=()
  IFS=':' read -r -a user_paths <<<"$EDGE_MOTION_REPO_SEARCH_PATHS"
  for candidate in "${user_paths[@]}"; do
    [[ -n "$candidate" ]] && search_dirs+=("$candidate")
  done

  search_dirs+=(
    "$PWD"
    "$HOME/edge-motion"
    "$HOME/projects/edge-motion"
    "$HOME/src/edge-motion"
    "/usr/local/src/edge-motion"
    "/opt/edge-motion"
  )

  for candidate in "${search_dirs[@]}"; do
    if is_repo_dir "$candidate"; then
      status "Репозиторий найден в альтернативном пути: $candidate"
      printf '%s' "$candidate"
      return 0
    fi
  done

  return 1
}

if ! EDGE_MOTION_REPO_DIR="$(find_repo_dir)"; then
  status "Репозиторий не найден (включая /opt/edge-motion-src и альтернативные пути), обновление пропущено."
  exit 0
fi

if ! git -C "$EDGE_MOTION_REPO_DIR" fetch origin "$EDGE_MOTION_UPDATE_BRANCH" --quiet; then
  status "Не удалось выполнить fetch, обновление пропущено."
  exit 0
fi

local_rev="$(git -C "$EDGE_MOTION_REPO_DIR" rev-parse HEAD)"
remote_rev="$(git -C "$EDGE_MOTION_REPO_DIR" rev-parse "origin/$EDGE_MOTION_UPDATE_BRANCH")"

if [[ "$local_rev" == "$remote_rev" ]]; then
  status "Обновления не найдены (уже актуальная версия)."
  exit 0
fi

tmp_dir="$(mktemp -d)"
cleanup() { rm -rf "$tmp_dir"; }
trap cleanup EXIT

if ! git -C "$EDGE_MOTION_REPO_DIR" worktree add --detach "$tmp_dir" "origin/$EDGE_MOTION_UPDATE_BRANCH" >/dev/null 2>&1; then
  status "Не удалось создать временный worktree, обновление пропущено."
  exit 0
fi

if make -C "$tmp_dir" deps-check >/dev/null 2>&1 && make -C "$tmp_dir" build >/dev/null 2>&1 && make -C "$tmp_dir" install >/dev/null 2>&1; then
  if git -C "$EDGE_MOTION_REPO_DIR" merge --ff-only "origin/$EDGE_MOTION_UPDATE_BRANCH" >/dev/null 2>&1; then
    status "Успешно обновлено до $remote_rev."
  else
    status "Сборка/установка успешна, но локальный репозиторий не был fast-forward."
  fi

  status "Изменения в обновлении:"
  git -C "$EDGE_MOTION_REPO_DIR" log --no-merges --pretty='- %s' "$local_rev..$remote_rev" | head -n 8 | while IFS= read -r line; do
    status "$line"
  done

  if [[ -f "$tmp_dir/CHANGELOG.md" ]]; then
    status "Пользовательские заметки к релизу:"
    awk 'NR>1 && /^## / {exit} NR>1 {print}' "$tmp_dir/CHANGELOG.md" | sed '/^$/d' | head -n 10 | while IFS= read -r line; do
      status "$line"
    done
  fi
else
  status "Ошибка во время сборки/установки обновления; текущая версия сохранена."
fi

git -C "$EDGE_MOTION_REPO_DIR" worktree remove "$tmp_dir" --force >/dev/null 2>&1 || true
